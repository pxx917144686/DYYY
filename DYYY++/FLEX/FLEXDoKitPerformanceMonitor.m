#import "FLEXDoKitPerformanceMonitor.h"
#import <mach/mach.h>
#import <sys/sysctl.h>
#import <sys/types.h>
#import <sys/time.h>

// ÂÖºÂÆπÊÄßÂ§ÑÁêÜ
#ifndef __has_include
#define __has_include(x) 0
#endif

#if __has_include(<ifaddrs.h>)
#import <ifaddrs.h>
#import <net/if.h>
#import <net/if_dl.h>
#define FLEX_NETWORK_MONITORING_AVAILABLE 1
#else
#define FLEX_NETWORK_MONITORING_AVAILABLE 0
#warning "ÁΩëÁªúÁõëÊéßÂäüËÉΩ‰∏çÂèØÁî®ÔºöÁº∫Â∞ëifaddrs.hÊîØÊåÅ"
#endif

@interface FLEXDoKitPerformanceMonitor ()
@property (nonatomic, strong) CADisplayLink *fpsDisplayLink;
@property (nonatomic, strong) NSTimer *cpuTimer;
@property (nonatomic, strong) NSTimer *memoryTimer;
@property (nonatomic, strong) CADisplayLink *lagDetectionDisplayLink;
@property (nonatomic, strong) NSTimer *networkTimer;
@property (nonatomic, assign) CFTimeInterval lastFPSTime;
@property (nonatomic, assign) CFTimeInterval lastLagCheckTime;
@property (nonatomic, assign) NSInteger fpsCount;
@property (nonatomic, assign) NSInteger lagFrameCount;
@property (nonatomic, assign) uint64_t uploadFlowBytes;
@property (nonatomic, assign) uint64_t downloadFlowBytes;
@end

@implementation FLEXDoKitPerformanceMonitor

+ (instancetype)sharedInstance {
    static FLEXDoKitPerformanceMonitor *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (void)startFPSMonitoring {
    if (self.fpsDisplayLink) return;
    
    self.fpsDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(fpsDisplayLinkTick:)];
    [self.fpsDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
    self.lastFPSTime = CACurrentMediaTime();
    self.fpsCount = 0;
}

- (void)stopFPSMonitoring {
    [self.fpsDisplayLink invalidate];
    self.fpsDisplayLink = nil;
}

- (void)fpsDisplayLinkTick:(CADisplayLink *)displayLink {
    self.fpsCount++;
    CFTimeInterval currentTime = CACurrentMediaTime();
    CFTimeInterval deltaTime = currentTime - self.lastFPSTime;
    
    if (deltaTime >= 1.0) {
        _currentFPS = self.fpsCount / deltaTime;
        self.fpsCount = 0;
        self.lastFPSTime = currentTime;
        
        // ÂèëÈÄÅFPSÊõ¥Êñ∞ÈÄöÁü•
        [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitFPSUpdated" 
                                                            object:@(self.currentFPS)];
    }
}

- (void)startCPUMonitoring {
    if (self.cpuTimer) return;
    
    self.cpuTimer = [NSTimer scheduledTimerWithTimeInterval:0.5
                                                     target:self
                                                   selector:@selector(updateCPUUsage)
                                                   userInfo:nil
                                                    repeats:YES];
}

- (void)stopCPUMonitoring {
    [self.cpuTimer invalidate];
    self.cpuTimer = nil;
}

- (void)updateCPUUsage {
    thread_act_array_t threads;
    mach_msg_type_number_t threadCount = 0;
    
    if (task_threads(mach_task_self(), &threads, &threadCount) != KERN_SUCCESS) {
        return;
    }
    
    double totalCPU = 0;
    for (int i = 0; i < threadCount; i++) {
        thread_info_data_t threadInfo;
        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;
        
        if (thread_info(threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &threadInfoCount) == KERN_SUCCESS) {
            thread_basic_info_t basicInfo = (thread_basic_info_t)threadInfo;
            if (!(basicInfo->flags & TH_FLAGS_IDLE)) {
                totalCPU += basicInfo->cpu_usage / (double)TH_USAGE_SCALE * 100.0;
            }
        }
    }
    
    vm_deallocate(mach_task_self(), (vm_offset_t)threads, threadCount * sizeof(thread_t));
    
    _currentCPUUsage = totalCPU;
    [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitCPUUpdated" 
                                                        object:@(self.currentCPUUsage)];
}

- (void)startMemoryMonitoring {
    if (self.memoryTimer) return;
    
    self.memoryTimer = [NSTimer scheduledTimerWithTimeInterval:1.0
                                                        target:self
                                                      selector:@selector(updateMemoryUsage)
                                                      userInfo:nil
                                                       repeats:YES];
}

- (void)stopMemoryMonitoring {
    [self.memoryTimer invalidate];
    self.memoryTimer = nil;
}

- (void)updateMemoryUsage {
    vm_size_t page_size;
    mach_port_t mach_port = mach_host_self();
    host_page_size(mach_port, &page_size);
    
    vm_statistics64_data_t vm_stat;
    mach_msg_type_number_t host_size = sizeof(vm_statistics64_data_t) / sizeof(natural_t);
    host_statistics64(mach_port, HOST_VM_INFO, (host_info64_t)&vm_stat, &host_size);
    
    // ËÆ°ÁÆóÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµÔºàMBÔºâ
    uint64_t used_memory = (uint64_t)(vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count) * page_size;
    _currentMemoryUsage = used_memory / (1024.0 * 1024.0);
    
    // ÂèëÈÄÅÂÜÖÂ≠òÊõ¥Êñ∞ÈÄöÁü•
    [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitMemoryUpdated" 
                                                        object:@(self.currentMemoryUsage)];
}

- (void)startLagDetection {
    // ‰ΩøÁî®CADisplayLinkÊ£ÄÊµã‰∏ªÁ∫øÁ®ãÂç°È°ø
    if (self.lagDetectionDisplayLink) {
        [self stopLagDetection];
    }
    
    self.lagDetectionDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(lagDetectionTick:)];
    [self.lagDetectionDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
    
    self.lastLagCheckTime = CACurrentMediaTime();
    self.lagFrameCount = 0;
    
    NSLog(@"‚úÖ Âç°È°øÊ£ÄÊµãÂ∑≤ÂêØÂä®");
}

- (void)stopLagDetection {
    if (self.lagDetectionDisplayLink) {
        [self.lagDetectionDisplayLink invalidate];
        self.lagDetectionDisplayLink = nil;
        NSLog(@"‚úÖ Âç°È°øÊ£ÄÊµãÂ∑≤ÂÅúÊ≠¢");
    }
}

- (void)lagDetectionTick:(CADisplayLink *)displayLink {
    CFTimeInterval currentTime = CACurrentMediaTime();
    CFTimeInterval deltaTime = currentTime - self.lastLagCheckTime;
    
    // Ê≠£Â∏∏Â∏ßÁéáÂ∫îËØ•ÊòØ1/60 ‚âà 0.0167Áßí
    if (deltaTime > 0.033) { // Ë∂ÖËøá2Â∏ßÊó∂Èó¥ËÆ§‰∏∫ÊòØÂç°È°ø
        self.lagFrameCount++;
    }
    
    self.lastLagCheckTime = currentTime;
    
    // ÊØèÁßíÁªüËÆ°‰∏ÄÊ¨°Âç°È°øÊÉÖÂÜµ
    static CFTimeInterval lastReportTime = 0;
    if (currentTime - lastReportTime >= 1.0) {
        if (self.lagFrameCount > 0) {
            NSLog(@"‚ö†Ô∏è Ê£ÄÊµãÂà∞Âç°È°øÂ∏ß: %ld", (long)self.lagFrameCount);
            
            // ÂèëÈÄÅÂç°È°øÈÄöÁü•
            [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitLagDetected" 
                                                                object:@(self.lagFrameCount)];
        }
        
        self.lagFrameCount = 0;
        lastReportTime = currentTime;
    }
}

- (void)calculateAppLaunchTime {
    // Ëé∑ÂèñËøõÁ®ãÂêØÂä®Êó∂Èó¥
    struct kinfo_proc proc;
    size_t size = sizeof(proc);
    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()};
    
    if (sysctl(mib, 4, &proc, &size, NULL, 0) == 0) {
        struct timeval startTime = proc.kp_proc.p_starttime;
        
        // ËÆ°ÁÆóÂêØÂä®Âà∞Áé∞Âú®ÁöÑÊó∂Èó¥
        struct timeval currentTime;
        gettimeofday(&currentTime, NULL);
        
        NSTimeInterval launchTime = (currentTime.tv_sec - startTime.tv_sec) + 
                                   (currentTime.tv_usec - startTime.tv_usec) / 1000000.0;
        
        _appLaunchTime = launchTime;
        
        NSLog(@"üì± Â∫îÁî®ÂêØÂä®ËÄóÊó∂: %.3fÁßí", launchTime);
        
        // ÂèëÈÄÅÂêØÂä®Êó∂Èó¥ÈÄöÁü•
        [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitAppLaunchTimeCalculated" 
                                                            object:@(launchTime)];
    } else {
        NSLog(@"‚ùå Êó†Ê≥ïËÆ°ÁÆóÂ∫îÁî®ÂêØÂä®Êó∂Èó¥");
        _appLaunchTime = 0;
    }
}

- (void)startNetworkMonitoring {
    // ÂêØÂä®ÁΩëÁªúÊµÅÈáèÁõëÊéß
    if (self.networkTimer) return;
    
    self.networkTimer = [NSTimer scheduledTimerWithTimeInterval:1.0
                                                         target:self
                                                       selector:@selector(updateNetworkUsage)
                                                       userInfo:nil
                                                        repeats:YES];
    
    [self resetNetworkCounters];
}

- (void)stopNetworkMonitoring {
    [self.networkTimer invalidate];
    self.networkTimer = nil;
}

- (void)updateNetworkUsage {
#if FLEX_NETWORK_MONITORING_AVAILABLE
    // ‚úÖ Âè™Âú®ÊîØÊåÅÁöÑÂπ≥Âè∞‰∏äÁºñËØëÁΩëÁªúÁõëÊéß‰ª£Á†Å
    struct ifaddrs *addrs = NULL;
    
    @try {
        if (getifaddrs(&addrs) == 0) {
            struct ifaddrs *cursor = addrs;
            
            uint64_t totalUploadBytes = 0;
            uint64_t totalDownloadBytes = 0;
            
            while (cursor != NULL) {
                // ‚úÖ Ê£ÄÊü•ÁΩëÁªúÊé•Âè£Á±ªÂûã
                if (cursor->ifa_addr && cursor->ifa_addr->sa_family == AF_LINK) {
                    struct if_data *if_data = (struct if_data *)cursor->ifa_data;
                    if (if_data) {
                        totalUploadBytes += if_data->ifi_obytes;
                        totalDownloadBytes += if_data->ifi_ibytes;
                    }
                }
                cursor = cursor->ifa_next;
            }
            
            // ËÆ°ÁÆóÊµÅÈáèÈÄüÂ∫¶ÔºàÂ≠óËäÇ/ÁßíÔºâ
            static uint64_t lastUploadBytes = 0;
            static uint64_t lastDownloadBytes = 0;
            
            if (lastUploadBytes > 0 && lastDownloadBytes > 0) {
                _uploadFlowBytes = totalUploadBytes - lastUploadBytes;
                _downloadFlowBytes = totalDownloadBytes - lastDownloadBytes;
            } else {
                // È¶ñÊ¨°ËøêË°åÔºåÂàùÂßãÂåñ
                _uploadFlowBytes = 0;
                _downloadFlowBytes = 0;
            }
            
            lastUploadBytes = totalUploadBytes;
            lastDownloadBytes = totalDownloadBytes;
            
            // ÂèëÈÄÅÁΩëÁªúÊõ¥Êñ∞ÈÄöÁü•
            NSDictionary *networkInfo = @{
                @"upload": @(self.uploadFlowBytes),
                @"download": @(self.downloadFlowBytes),
                @"totalUpload": @(totalUploadBytes),
                @"totalDownload": @(totalDownloadBytes)
            };
            
            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitNetworkUpdated" 
                                                                    object:networkInfo];
            });
            
        } else {
            NSLog(@"‚ö†Ô∏è Ëé∑ÂèñÁΩëÁªúÊé•Âè£‰ø°ÊÅØÂ§±Ë¥•");
        }
        
    } @finally {
        if (addrs) {
            freeifaddrs(addrs);
        }
    }
#else
    // ‰∏çÊîØÊåÅÁΩëÁªúÁõëÊéßÁöÑÂπ≥Âè∞
    NSLog(@"‚ö†Ô∏è ÂΩìÂâçÂπ≥Âè∞‰∏çÊîØÊåÅÁΩëÁªúÁõëÊéßÂäüËÉΩ");
    
    // ÂèëÈÄÅÁ©∫ÁöÑÁΩëÁªú‰ø°ÊÅØ
    NSDictionary *networkInfo = @{
        @"upload": @0,
        @"download": @0,
        @"error": @"‰∏çÊîØÊåÅÁΩëÁªúÁõëÊéß"
    };
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:@"FLEXDoKitNetworkUpdated" 
                                                            object:networkInfo];
    });
#endif
}

- (void)resetNetworkCounters {
    _uploadFlowBytes = 0;
    _downloadFlowBytes = 0;
}

@end